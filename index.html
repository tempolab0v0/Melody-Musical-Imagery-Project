<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Melody's Mystery Elevator</title>
  <style>
    :root { --bar-h: 10px; }

    html, body {
      height: 100%;
      margin: 0;
      background: #fff;
      font-family: Arial, sans-serif;
      text-align: center;
    }
    /* Prevent background page scroll; let #screen scroll instead if needed */
    body { overflow: hidden; }

    /* FILL the visible viewport on phones/tablets/desktops */
    #visual-container{
      width: 100vw;
      height: 100dvh;             /* dynamic viewport height (mobile-safe) */
      margin: 0;
      max-width: none;
      max-height: none;
      background: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 12px rgba(0,0,0,.07);
      overflow: hidden;
      position: relative;
    }

    /* Centered content layer; scroll here if text is long */
    #screen{
      position: absolute; inset: 0;
      display: flex; align-items: center; justify-content: center;
      flex-direction: column;
      background: transparent;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      padding: clamp(12px, 2vh, 24px);
      /* keep a little space under the progress bar */
      padding-top: calc(var(--bar-h) + 8px);
    }

    .media-content {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: none;
      position: absolute;
      inset: 0;
      background:#fff;
    }
    #visual-container video,
    #visual-container img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background:#fff;
    }

    #overlay{
      position: fixed; inset: 0;
      background:#fff;
      display: none; /* shown only when autoplay is blocked */
      flex-direction: column;
      align-items: center; justify-content: center;
      z-index: 1200;
      padding: 16px;
    }

   .btn-primary{
  padding: clamp(24px, 5vw, 48px) clamp(40px, 10vw, 96px);
  font-size: clamp(1.5rem, 4vw, 2.5rem);
  border-radius: 24px;
  border: none;
  background: linear-gradient(135deg,#f3e7ff,#d0b3ff);
  color: #4b2e83;
  font-weight: bold;
  cursor: pointer;
  box-shadow: 0 4px 18px rgba(75,46,131,.3);
  transition: transform .2s, box-shadow .2s;
}
.btn-primary:hover{
  transform: scale(1.07);
  box-shadow: 0 8px 24px rgba(75,46,131,.4);
}
    
.response-wrapper {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: clamp(20px, 5vw, 56px);
    box-sizing: border-box;
  }

.response-screen {
    width: min(920px, 100%);
    margin: 0 auto;
    background: linear-gradient(145deg, #ffffff, #f5ecff);
    border-radius: 28px;
    padding: clamp(20px, 4vw, 42px);
    box-shadow: 0 24px 50px rgba(75,46,131,.15);
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    gap: clamp(16px, 3vh, 28px);
  }

  .response-screen h1 {
    margin: 0;
    color: #4b2e83;
    font-size: clamp(1.5rem, 4vw, 2.4rem);
  }

.response-options {
    width: 100%;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: clamp(18px, 4vw, 32px);
  }

.tempo-btn {
    cursor: pointer;
    transition: transform .2s, box-shadow .2s;
    padding: clamp(16px, 3.5vw, 28px);
    border-radius: 24px;
    border: none;
    width: 100%;
    min-height: clamp(140px, 22vh, 210px);
    background: linear-gradient(135deg,#f3e7ff,#d0b3ff);
    color: #4b2e83;
    font-weight: 700;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: clamp(10px, 2.8vh, 18px);
    box-shadow: 0 8px 26px rgba(75,46,131,.16);
    text-align: center;
  }

  .tempo-btn:hover {
    transform: translateY(-4px);
    box-shadow: 0 14px 32px rgba(75,46,131,.22);
  }

  .tempo-btn:disabled {
    opacity: .65;
    cursor: not-allowed;
    transform: none;
    box-shadow: 0 8px 26px rgba(75,46,131,.16);
  }

  .tempo-btn .option-icon {
    width: clamp(48px, 12vw, 72px);
    height: clamp(48px, 12vw, 72px);
    object-fit: contain;
  }

  .tempo-btn span {
    font-size: clamp(1.1rem, 2.8vw, 1.6rem);
    letter-spacing: 0.02em;
  }

  .response-feedback {
    margin-top: clamp(12px, 3vh, 20px);
    font-size: clamp(1.1rem, 2.8vw, 1.5rem);
    font-weight: 600;
    color: #4b2e83;
  }
    
  .elevator-option {
    cursor: pointer;
    transition: transform .2s, box-shadow .2s;
    border-radius: 20px;
    box-shadow: 0 4px 18px rgba(75,46,131,.12);
  }

  .elevator-option:hover {
    transform: scale(1.07);
    box-shadow: 0 8px 24px rgba(75,46,131,.18);
  }

    /* thin progress bar, above everything except overlay */
    #progressWrapper{
      position:fixed; top:0; left:0; width:100%;
      height: var(--bar-h);
      background:#eee;
      z-index:1100;
    }
    #progressBar{height:100%;width:0;background:#4b2e83;transition:width .3s;}

    /* Keep trial button visible at bottom of the screen */
    #trialControls{
      position: fixed;
      left: 0; right: 0;
      bottom: calc(env(safe-area-inset-bottom, 0px) + 12px);
      display: flex; justify-content: center; gap: 12px;
      z-index: 1150;
      pointer-events: none;         /* container ignores clicks */
    }
    #trialControls .btn-primary { pointer-events: auto; } /* buttons clickable */
  </style>
</head>
  
<body>
  <div id="overlay" style="display:none;"></div>
  <div id="progressWrapper"><div id="progressBar"></div></div>
  <div id="visual-container">
    <div id="screen"></div>
    <img class="media-content" id="stillframe1" src="stillframe1.png"/>
    <img class="media-content" id="gapStillframe" src="gapStillframe.png"/>
    <img class="media-content" id="stillframe2" src="stillframe2.png"/>
    <video class="media-content" id="video1" src="video1.mp4" playsinline preload="auto" muted></video>
    <video class="media-content" id="gapVideo" src="gapVideo.mp4"playsinline preload="auto" muted></video>
    <video class="media-content" id="video2" src="video2.mp4" playsinline preload="auto" muted></video>
  </div>
  <audio id="myAudio" hidden preload="auto"></audio>
  <audio id="narrationAudio" hidden preload="auto"></audio>
  <audio id="introNarration" src="intro_narration.mp3" hidden preload="auto"></audio>
  <div id="trialControls"></div>

<script>  
// Fallback and dynamic trial handling
const FALLBACK_TRIALS_PER_BLOCK = 16;
const BLOCK_ORDER=["tempo","pitch"];
const BLOCK_FILES = { tempo: "tempo_trials.csv", pitch: "pitch_trials.csv" };
const ANIMALS_PER_BLOCK = 3;
const REAL_BLOCK_ANIMAL_TRIALS = {
  tempo: [4, 8, 12],
  pitch: [4, 8, 12],
};
const ANIMALS = [
  {name:"Tiger", image:"tiger.png", sound:"tiger.mp3", action:"Paws up! Roar like a tiger 3 times!"},
  {name:"Lion", image:"lion.png", sound:"lion.mp3", action:"Stand tall like a lion. Reach up high and hold a big stretch for 5 seconds."},
  {name:"Penguin", image:"penguin.png", sound:"penguin.mp3", action:"Heels together, wings out! Waddle 6 steps in place while flapping."},
  {name:"Monkey", image:"monkey.png", sound:"monkey.mp3", action:"Scratch and giggle like a silly monkey - ooh-ooh, aah-aah!"},
  {name:"Elephant", image:"elephant.png", sound:"elephant.mp3", action:"One arm is your trunk. Swing it side-to-side and stomp 5 slow steps."},
  {name:"Parrot", image:"parrot.png", sound:"parrot.mp3", action:"Stand tall, flap 8 times, then give one big squawk — ‘SQUAWK!’"}
];

const BACKENDLESS_URL = "https://api.backendless.com/04D99C8B-3B22-454C-889B-5E66A5798C47/38037288-90E3-4F8A-87D6-E052FCD03D67/data/responses";
const OFFLINE_QUEUE_KEY = "melody_offline_responses";

function loadOfflineQueue() {
  if (typeof localStorage === "undefined") return [];
  try {
    const raw = localStorage.getItem(OFFLINE_QUEUE_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : [];
  } catch (err) {
    console.warn("Failed to read offline response queue", err);
    return [];
  }
}

function storeOfflineQueue(queue) {
  if (typeof localStorage === "undefined") return;
  try {
    localStorage.setItem(OFFLINE_QUEUE_KEY, JSON.stringify(queue));
  } catch (err) {
    console.warn("Failed to persist offline response queue", err);
  }
}

function queueOfflineResponse(entry, error) {
  try {
    const queue = loadOfflineQueue();
    queue.push({
      entry,
      queuedAt: new Date().toISOString(),
      error: error ? (error.message || String(error)) : undefined
    });
    storeOfflineQueue(queue);
    return true;
  } catch (err) {
    console.error("Failed to queue offline response", err);
    return false;
  }
}

async function flushOfflineQueue() {
  const queue = loadOfflineQueue();
  if (!queue.length) return;

  const remaining = [];
  for (const item of queue) {
    try {
      await postResponseToServer(item.entry);
    } catch (err) {
      remaining.push(item);
    }
  }

  storeOfflineQueue(remaining);
}

async function postResponseToServer(entry) {
  const response = await fetch(BACKENDLESS_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(entry)
  });

  const contentType = response.headers?.get?.("content-type") || "";
  let payload = null;

  if (contentType.includes("application/json")) {
    try {
      payload = await response.json();
    } catch (err) {
      console.warn("Failed to parse Backendless JSON response", err);
    }
  } else {
    const text = await response.text().catch(() => "");
    if (text) payload = { message: text };
  }

  if (!response.ok) {
    const message = payload?.message || payload?.error || `HTTP ${response.status}`;
    throw new Error(message);
  }

  if (payload && typeof payload === "object" && "statusCode" in payload && "message" in payload) {
    throw new Error(`${payload.statusCode}: ${payload.message}`);
  }

  return payload;
}

let pitchPracticeCompleted = false;

let blocks={tempo:[],pitch:[]};
let currentBlockIndex=0;
let trialCounter=1;
let participantID=null;
let sessionID=null;
let currentAudioFile="";
let responseSubmitted=false;
let trialStartTime=null;
const visuals=[];
let completedTrials=0;
let animalIndex = 0;
let currentAnimalAudio = null;
let trialsInCurrentBlock = 0;
let animalsShownInBlock = 0;

function trialsFor(block) {
  const len = blocks[block] && Array.isArray(blocks[block]) ? blocks[block].length : 0;
  return len > 0 ? len : FALLBACK_TRIALS_PER_BLOCK;
}

function animalIntervalFor(block) {
  const t = trialsFor(block) || 1;
  return Math.max(1, Math.ceil(t / ANIMALS_PER_BLOCK));
}

function totalTrialsCount() {
  return BLOCK_ORDER.reduce((sum, b) => sum + (blocks[b] && Array.isArray(blocks[b]) && blocks[b].length ? blocks[b].length : FALLBACK_TRIALS_PER_BLOCK), 0);
}

function waitForAudioReady(audioEl) {
  return new Promise((resolve, reject) => {
    const haveEnough =
      typeof HTMLMediaElement !== "undefined" && HTMLMediaElement.HAVE_ENOUGH_DATA
        ? HTMLMediaElement.HAVE_ENOUGH_DATA
        : 4;

    if (audioEl.readyState >= haveEnough) {
      resolve();
      return;
    }

    const cleanup = () => {
      audioEl.removeEventListener("canplaythrough", onReady);
      audioEl.removeEventListener("loadeddata", onReady);
      audioEl.removeEventListener("error", onError);
    };

    const onReady = () => {
      cleanup();
      resolve();
    };

    const onError = () => {
      cleanup();
      reject(new Error("Audio failed to load."));
    };

    audioEl.addEventListener("canplaythrough", onReady, { once: true });
    audioEl.addEventListener("loadeddata", onReady, { once: true });
    audioEl.addEventListener("error", onError, { once: true });
  });
}

// ---- WebAudio booster (gesture-safe) ---------------------------------
const AudioEngine = (() => {
  let ctx = null, comp = null;
  const sources = new Map();        // el -> { src, gain, group }
  const pending = new Set();        // elements seen before ctx starts
  const groups = {
    narration: 0.5,  // voice MP3s
    sfx:       0.5,  // correct/wrong/animals
    video:     12.0,  // quiet MP4s
    music:     20.0   // #myAudio trials
  };

  function groupFor(el) {
    const id = (el.id || "").toLowerCase();
    if (id.includes("narration")) return "narration";
    if (id.includes("correct") || id.includes("wrong") || id.includes("animal")) return "sfx";
    if (el.tagName === "VIDEO") return "video";
    if (id === "myaudio") return "music";
    return "music";
  }

  function ensureCompressor() {
    if (!ctx) return null;
    if (comp) return comp;
    comp = ctx.createDynamicsCompressor();
    comp.threshold.setValueAtTime(-20, ctx.currentTime);
    comp.knee.setValueAtTime(20, ctx.currentTime);
    comp.ratio.setValueAtTime(3, ctx.currentTime);
    comp.attack.setValueAtTime(0.003, ctx.currentTime);
    comp.release.setValueAtTime(0.15, ctx.currentTime);
    comp.connect(ctx.destination);
    return comp;
  }

  function wire(el) {
    if (!ctx) { pending.add(el); return; }          // wait for gesture
    if (sources.has(el)) return;
    const src = ctx.createMediaElementSource(el);
    const gain = ctx.createGain();
    const gg = groupFor(el);
    gain.gain.value = groups[gg] ?? 1.0;
    const compressor = ensureCompressor();
    src.connect(gain).connect(compressor ?? ctx.destination);
    sources.set(el, { src, gain, group: gg });
  }

  function attach(el) { wire(el); }

  function attachAll(scope = document) {
    scope.querySelectorAll("audio, video").forEach(wire);
  }

  async function start() {
    if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
    try { await ctx.resume(); } catch {}
    ensureCompressor();
    if (pending.size) {
      const toWire = Array.from(pending);
      pending.clear();
      toWire.forEach(wire);
    }
  }

  function setGroupGain(group, value) {
    groups[group] = value;
    for (const rec of sources.values()) {
      if (rec.group === group) rec.gain.gain.value = value;
    }
  }

return { start, attach, attachAll, setGroupGain, groups };
})();

async function saveResponse(entry, { maxAttempts = 3, retryDelayMs = 500 } = {}) {
  let lastError = null;

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await postResponseToServer(entry);
    } catch (err) {
      lastError = err;
      if (attempt < maxAttempts) {
        await new Promise(res => setTimeout(res, retryDelayMs * attempt));
      }
    }
  }

  throw lastError ?? new Error("Failed to save response");
}

window.addEventListener("online", () => {
  flushOfflineQueue().catch(err => console.warn("Failed to flush offline queue", err));
});

window.onload = async () => {
  // Prime WebAudio on first gesture (click/touch/key)
  const prime = async () => {
    await AudioEngine.start();
    AudioEngine.attachAll(document);               // wire everything now that ctx is allowed

    AudioEngine.setGroupGain("video", 5.0); 
    AudioEngine.setGroupGain("music", 3.0);
    AudioEngine.setGroupGain("narration", 0.8);
    AudioEngine.setGroupGain("sfx", 0.8);
  };

    flushOfflineQueue().catch(err => console.warn("Failed to flush offline queue on load", err));

  window.addEventListener("click", prime, { once: true });
  window.addEventListener("touchend", prime, { once: true });
  window.addEventListener("keydown", prime, { once: true });

  while (!participantID) {
    participantID = prompt("Enter your Participant ID:");
    if (participantID) participantID = participantID.trim();
  }
  sessionID = `${participantID}_${new Date().toISOString()}`;

  for (const block of BLOCK_ORDER) {
    try { await loadCSVData(block); }
    catch (err) { alert(`Failed to load ${block} trials: ${err.message}`); }
  }

  prepareShuffledBlocks();

// Shuffle helper (Fisher-Yates). Accepts an RNG function that returns [0,1).
function shuffleArrayInPlace(arr, rng = Math.random) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
  return arr;
}

// small seeded RNG (mulberry32) and seed derivation from string
function mulberry32(seed) {
  return function() {
    let t = seed += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function hashStringToSeed(str) {
  // lightweight hash -> 32-bit unsigned
  let h = 2166136261 >>> 0;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619) >>> 0;
  }
  return h >>> 0;
}

// call this after loadCSVData has populated blocks[block]
function prepareShuffledBlocks({ useSeed = true } = {}) {
  if (!participantID) {
    console.warn("prepareShuffledBlocks: participantID missing — not seeding shuffle");
  }
  for (const block of BLOCK_ORDER) {
    const rows = blocks[block];
    if (!Array.isArray(rows) || rows.length === 0) continue;

    // key used to persist the order for this participant/session
    const orderKey = `melody_order_${participantID}_${block}`;

    // If there's a saved permutation (sessionStorage), restore it
    const saved = sessionStorage.getItem(orderKey);
    if (saved) {
      try {
        const indices = JSON.parse(saved);
        if (Array.isArray(indices) && indices.length === rows.length) {
          // reorder according to saved indices
          blocks[block] = indices.map(i => rows[i]);
          console.log(`Restored saved order for block ${block}`);
          continue;
        } else {
          console.warn("Saved order invalid or length mismatch; will reshuffle");
        }
      } catch (e) {
        console.warn("Failed to parse saved shuffle order:", e);
      }
    }

    // No saved order: create a new shuffled permutation and persist the indices
    const n = rows.length;
    const indices = Array.from({ length: n }, (_, i) => i);

    // optional reproducible seed (per participant)
    let rng = Math.random;
    if (useSeed && participantID) {
      const seed = hashStringToSeed(`${participantID}_${block}`);
      rng = mulberry32(seed);
    }

    shuffleArrayInPlace(indices, rng);

    // permute rows into new order
    const permuted = indices.map(i => rows[i]);
    blocks[block] = permuted;

    try {
      sessionStorage.setItem(orderKey, JSON.stringify(indices));
    } catch (e) {
      console.warn("Could not persist shuffle order (sessionStorage):", e);
    }

    console.log(`Shuffled ${block}: ${n} rows (persisted order key=${orderKey})`);
  }
}
  
  // Preload animal sounds (not in DOM) — safe to queue before gesture
  ANIMALS.forEach(a => { a.audio = new Audio(a.sound); AudioEngine.attach(a.audio); });

  showIntroScreen();
};

function updateScreen(html, background=null){
  const s = document.getElementById("screen");
  s.innerHTML = html;
  s.style.background = background !== null ? background : "transparent";
  AudioEngine.attachAll(s); // before gesture this queues; after gesture it wires immediately
}

/**
 * Robust CSV loader:
 * - supports comma or tab separated values
 * - trims fields
 * - skips blank lines
 * - logs helpful diagnostics
 */
async function loadCSVData(blockType) {
  const response = await fetch(BLOCK_FILES[blockType]);
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}`);
  }
  const text = await response.text();

  // split into lines safely, drop blank lines, remove header
  const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  if (lines.length <= 1) {
    blocks[blockType] = [];
    console.warn(`No data rows found for block ${blockType}`);
    return;
  }
  const dataLines = lines.slice(1);

  // Support both comma-separated and tab-separated rows.
  // Also trim fields and remove surrounding quotes if present.
  const parsed = dataLines.map(line => {
    // split on comma or tab; if quotes are used with commas inside this is a lightweight approach:
    // first try splitting on tab (common), then fallback to comma if no tabs found.
    const sep = line.includes('\t') ? '\t' : ',';
    const cells = line.split(sep).map(s => s.trim().replace(/^"(.*)"$/, '$1'));
    return cells;
  });

  // Validate shape and log if there are malformed rows
  const bad = parsed.filter(row => row.length < 4);
  if (bad.length) {
    console.warn(`Warning: ${bad.length} rows for ${blockType} have < 4 columns. First bad row:`, bad[0]);
  }
  blocks[blockType] = parsed;
  console.log(`Loaded ${parsed.length} trials for ${blockType}`);
}

function showIntroScreen() {
  updateScreen(`
    <div style="display:flex;align-items:center;justify-content:center;height:100%;padding:40px;box-sizing:border-box;">
      <div style="flex:1;display:flex;justify-content:center;">
        <img src="Melody.png" alt="Melody character" style="max-height:80vh;max-width:90%;border-radius:20px;" />
      </div>
      <div style="flex:1;padding:30px;">
        <button id="continueIntro" class="btn-primary" style="margin-bottom:24px;">Click to Play</button>
        <p style="font-size:1.5em;line-height:1.6;">
          Hi there!<br>
          My name is Melody, and I love music!<br>
          Every day, I ride a musical elevator to get to music class.<br>
          But today the elevator is full of surprises, and we might even meet some animal friends!<br>
          Will you help me figure out what's going on?
        </p>
        <audio id="introAudio" src="intro_narration.mp3"></audio>
      </div>
    </div>
  `);

  const introAudio = document.getElementById("introAudio");
  const continueBtn = document.getElementById("continueIntro");

  continueBtn.addEventListener("click", async () => {
    continueBtn.disabled = true;
    try {
      await introAudio.play();
    } catch (err) {
      console.warn("Autoplay blocked or failed:", err);
    }
    introAudio.onended = showIntroVideo;
  });
}

function showIntroVideo() {
  updateScreen(`
    <div style="display:flex;justify-content:center;align-items:center;height:100%;background:white;">
      <video id="introVideo" width="100%" height="100%" playsinline muted style="max-width:100%;max-height:100%;background:white;">
        <source src="intro_video.mp4" type="video/mp4" />
      </video>
      <audio id="introNarration2" src="intro_narration2.mp3"></audio>
    </div>
  `);

  const video = document.getElementById("introVideo");
  const narration = document.getElementById("introNarration2");

  const startPlayback = async () => {
    try {
      await Promise.all([video.play(), narration.play()]);
    } catch (err) {
      console.warn("Playback failed:", err);
    }
    video.onended = () => setTimeout(showNarrationScreen, 1000);
  };

  window.addEventListener("click", startPlayback, { once: true });
}

function showNarrationScreen() {
  updateScreen(`
    <div style="display:flex;justify-content:center;align-items:center;height:100%;background:white;padding:40px;box-sizing:border-box;">
      <div style="flex:1;display:flex;justify-content:center;">
        <img src="Melody.png" alt="Melody character" style="max-height:80vh;max-width:90%;border-radius:20px;" />
      </div>
<div style="flex:1;text-align:center;padding:30px;">
<button id="playNarration" class="btn-primary" style="margin-bottom:24px;">Click to Play</button>
        <p style="font-size:1.3em;line-height:1.8;">
         The magical elevator can do all sorts of silly things to the music!<br>
          Sometimes it makes the music go faster or slower.<br>
          Other times the notes jump higher or sink lower.<br>
          And when the doors open we might meet an animal pal with a fun move to try!<br><br>
          Let’s practice together so you know what to listen for!
        </p>
        <audio id="introNarration3" src="intro_narration3.mp3"></audio>
      </div>
    </div>
  `);

  const button = document.getElementById("playNarration");
  const audio = document.getElementById("introNarration3");

  button.addEventListener("click", async () => {
    button.disabled = true;
    try {
      await audio.play();
    } catch (err) {
      console.warn("Audio play failed:", err);
    }
    audio.onended = () => setTimeout(showFastIntro, 1500);
  });
}

/* --------------------- TEMPO PRACTICE FLOW ------------------------------------------------------------------------------------------------------------------------------- */

function showFastIntro() {
  updateScreen(`
    <div style="display:flex;justify-content:center;align-items:center;height:100%;background:white;padding:40px;box-sizing:border-box;">
      <p style="font-size:1.5em;line-height:1.8;max-width:800px;text-align:center;">
       First, we’re going to learn how the magical elevator makes music sound faster or slower.<br>
        Ready?<br>
        Listen to this song and pay attention to how the music changes to become faster when Melody rides the elevator to the second floor.
      </p>
      <audio id="fastNarration" src="PT_FAST1_NARRATION.mp3"></audio>
    </div>
  `);

  const narration = document.getElementById("fastNarration");
  narration.play().then(() => {
    narration.onended = playFastVideo;
  }).catch(err => {
    console.warn("Autoplay issue:", err);
    playFastVideo();
  });
}

function playFastVideo() {
  updateScreen(`
    <video id="fastVideo" width="100%" height="100%" playsinline style="background:white;">
      <source src="PT_FAST1.mp4" type="video/mp4" />
    </video>
  `);

  const video = document.getElementById("fastVideo");
  video.muted = false;
  video.play().catch(e => console.warn("Video play failed:", e));
  video.onended = showSlowIntro;
}

function showSlowIntro() {
  updateScreen(`
    <div style="display:flex;justify-content:center;align-items:center;height:100%;background:white;padding:40px;box-sizing:border-box;">
      <p style="font-size:1.5em;line-height:1.8;max-width:800px;text-align:center;">
        Whoa! That was a fast ride!<br><br>
        Let’s try one more.<br>
        Now Melody is going to go super sloooow. Listen carefully!
      </p>
      <audio id="slowNarration" src="PT_SLOW1_NARRATION.mp3"></audio>
    </div>
  `);

  const narration = document.getElementById("slowNarration");
  narration.play().then(() => {
    narration.onended = playSlowVideo;
  }).catch(err => {
    console.warn("Autoplay issue:", err);
    playSlowVideo();
  });
}

function playSlowVideo() {
  updateScreen(`
    <video id="slowVideo" width="100%" height="100%" playsinline style="background:white;">
      <source src="PT_SLOW1.mp4" type="video/mp4" />
    </video>
  `);

  const video = document.getElementById("slowVideo");
  video.muted = false;
  video.play().catch(e => console.warn("Video play failed:", e));
  video.onended = showTempoInstructions;
}

function showTempoInstructions() {
  setTimeout(() => {
    updateScreen(`
      <div style="display:flex;justify-content:center;align-items:center;height:100%;background:white;padding:40px;box-sizing:border-box;">
        <p style="font-size:1.5em;line-height:1.8;max-width:800px;text-align:center;">
          Great! Now it's your turn!<br><br>
          After each clip, decide whether the music got <strong>faster</strong>, <strong>slower</strong>, or stayed <strong>the same</strong>! <br>
          When you hear the music, listen closely and click your answer. <br><br>
          Let's begin!
        </p>
        <audio id="tempoInstructions" src="PT_TEMPO_INSTRUCTIONS.mp3"></audio>
      </div>
    `);

    const audio = document.getElementById("tempoInstructions");
    audio.play().then(() => {
      audio.onended = () => setTimeout(runTempoPractice, 1000);
    }).catch(err => {
      console.warn("Autoplay issue:", err);
      runTempoPractice();
    });
  }, 1500);
}

function runTempoPractice() {
  const practiceTrials = [
    { video: "PT_FAST2.mp4", correct: "fast" },
    { video: "PT_Same.mp4", correct: "same" },
    { video: "PT_SLOW2.mp4", correct: "slow" }
  ];
  let i = 0;
  let practiceTrialNum = 1;

  function nextPractice() {
    responseSubmitted = false; // Reset for each practice trial
    if (i >= practiceTrials.length) {
      currentBlockIndex = 0; // set tempo block
      trialCounter = 1;
      showRealTrialsIntro();
      return;
    }
    const trial = practiceTrials[i];
    const proceed = () => {
      i++;
      practiceTrialNum++;
      nextPractice();
    };
    playTempoPracticeVideo(trial.video, trial.correct, proceed, practiceTrialNum);
  }

  nextPractice();
}

function playTempoPracticeVideo(videoFile, correctAnswer, callback, trialNumber) {
  updateScreen(`
    <div style="width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:white;">
      <video id="practiceVideo" playsinline autoplay style="width:100%; height:100%; object-fit:contain; background:white;">
        <source src="${videoFile}" type="video/mp4">
      </video>
    </div>
  `);

  const video = document.getElementById("practiceVideo");
  video.muted = false;
  video.volume = 1.0;
  video.onended = () => {
    showTempoResponseScreen(correctAnswer, callback, videoFile, trialNumber);
  };

  video.play().catch(err => {
    console.warn("Autoplay issue or play failed:", err);
    showTempoResponseScreen(correctAnswer, callback, videoFile, trialNumber);
  });
}

function showTempoResponseScreen(correctAnswer, callback, videoFile, trialNumber) {
  updateScreen(`
    <div class="response-wrapper">
      <div class="response-screen">
        <audio id="tempoPromptAudio" src="tempo_prompt.mp3"></audio>
        <h1>How did the music sound?</h1>
        <div class="response-options">
          <button class="tempo-btn" data-choice="fast" disabled>
            <img src="fast_icon.jpg" alt="Fast" class="option-icon" />
            <span>Fast</span>
          </button>
          <button class="tempo-btn" data-choice="slow" disabled>
            <img src="slow_icon.jpg" alt="Slow" class="option-icon" />
            <span>Slow</span>
          </button>
          <button class="tempo-btn" data-choice="same" disabled>
            <img src="same_icon.jpg" alt="Same" class="option-icon" />
            <span>Same</span>
          </button>
        </div>
        <audio id="correctSound" src="correct_feedback.mp3"></audio>
        <audio id="wrongSound" src="wrong_feedback.mp3"></audio>
        <div id="feedback" class="response-feedback" role="status" aria-live="polite"></div>
      </div>
    </div>
  `);

  const tempoPromptAudio = document.getElementById("tempoPromptAudio");
  const buttons = document.querySelectorAll('.tempo-btn');
  if (tempoPromptAudio) {
    tempoPromptAudio.play().catch(() => {});
    tempoPromptAudio.onended = () => {
      buttons.forEach(btn => btn.disabled = false);
    };
  } else {
    buttons.forEach(btn => btn.disabled = false);
  }

  let answered = false;
  const responseStart = performance.now();
  const feedbackEl = document.getElementById("feedback");
  const correctSound = document.getElementById("correctSound");
  const wrongSound = document.getElementById("wrongSound");
  const successColor = "#2e7d32";
  const errorColor = "#c62828";

  buttons.forEach(btn => {
    btn.addEventListener('click', () => {
      if (answered) return;
      answered = true;

      const userChoice = btn.getAttribute('data-choice');
      buttons.forEach(b => b.disabled = true);
      const reactionTimeSec = parseFloat(((performance.now() - responseStart) / 1000).toFixed(3));
      const entry = {
        participant: participantID,
        session: sessionID,
        block: "tempo_practice",
        trial_num: trialNumber,
        timestamp: new Date().toISOString(),
        choice: userChoice,
        audio: videoFile,
        correct_answer: correctAnswer,
        reaction_time_sec: reactionTimeSec,
        trial_phase: "practice"
      };

       saveResponse(entry)
.then(() => {
  let feedbackText = "";
  let feedbackAudioSrc = "";
  if (userChoice === correctAnswer) {
    if (correctAnswer === "same") {
      feedbackText = "Correct! It was the same! That means Melody must have been in a normal elevator this time and not a magical one.";
      feedbackAudioSrc = "feedback_normal.mp3";
    } else {
      feedbackText = "Correct! That means Melody must have been in a magical elevator!";
      feedbackAudioSrc = "feedback_magical.mp3";
    }
    feedbackEl.style.color = successColor;
    feedbackEl.innerText = feedbackText;
    const feedbackAudio = new Audio(feedbackAudioSrc);
    AudioEngine.attach(feedbackAudio);
    feedbackAudio.play().catch(() => {});
    feedbackAudio.onended = () => setTimeout(callback, 1000);
  } else {
    feedbackEl.style.color = errorColor;
    feedbackEl.innerText = "Oops! Let's try that one again.";
    wrongSound.play().catch(() => {});
    wrongSound.onended = () => {
      setTimeout(() => {
        playTempoPracticeVideo(
          videoFile,
          correctAnswer,
          callback,
          trialNumber
        );
      }, 500);
    };
  }
})
 .catch((err) => {
          console.error("Failed to record tempo practice response", err);
          queueOfflineResponse(entry, err);
          flushOfflineQueue().catch(e => console.warn("Failed to flush offline queue after queuing practice response", e));
          feedbackEl.style.color = errorColor;
          feedbackEl.innerText = "We couldn't save your answer. Please try again.";
          answered = false;
          buttons.forEach(b => b.disabled = false);
        });
    });
  });
}
  
function runPitchDemo() {
  updateScreen(`
    <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;background:white;padding:40px;box-sizing:border-box;">
      <p style="font-size:1.5em;line-height:1.6;max-width:800px;text-align:center;">
        <strong>6. Pitch Practice Trials</strong><br><br>
        Now, the magical elevator is going to change how high or low the music sounds.<br>
        Ready? Listen to this song and see how the music gets higher when Melody rides the elevator up to the 2nd floor.
      </p>
      <audio id="pitchIntroNarration" src="PT_PITCH_INTRO.mp3" preload="auto"></audio>
    </div>
  `);

  const narrEl = document.getElementById("pitchIntroNarration");
  AudioEngine.attach(narrEl);

  narrEl.play()
    .then(() => {
      narrEl.onended = playHighDemo; // Auto-play demo after narration
    })
    .catch(() => {
      playHighDemo(); // If autoplay blocked, just play demo
    });
}


  function playHighDemo() {
    updateScreen(`
      <video id="highDemo" width="100%" height="100%" playsinline style="background:white;">
        <source src="PT_HIGH1.mp4" type="video/mp4" />
      </video>
    `);
    const video = document.getElementById("highDemo");
    video.muted = false;
    video.play().catch(() => {});
    video.onended = showLowText;
  }

function showLowText() {
  updateScreen(`
    <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;background:white;padding:40px;box-sizing:border-box;">
      <p style="font-size:1.5em;line-height:1.6;max-width:800px;text-align:center;">
        That was super high!<br><br>
        Let’s try another, but this time, the notes will go lower.
      </p>
      <audio id="lowIntroNarration" src="PT_LOW1_INTRO.mp3" preload="auto"></audio>
    </div>
  `);

  const narrEl = document.getElementById("lowIntroNarration");
  AudioEngine.attach(narrEl);

  narrEl.play()
    .then(() => {
      narrEl.onended = playLowDemo; // Auto-play demo after narration
    })
    .catch(() => {
      playLowDemo(); // If autoplay blocked, just play demo
    });
}
  
  function playLowDemo() {
    updateScreen(`
      <video id="lowDemo" width="100%" height="100%" playsinline style="background:white;">
        <source src="PT_LOW1.mp4" type="video/mp4" />
      </video>
    `);
    const video = document.getElementById("lowDemo");
    video.muted = false;
    video.play().catch(() => {});
    video.onended = showFinalText;
  }

function showFinalText() {
  updateScreen(`
    <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;background:white;padding:40px;box-sizing:border-box;">
      <p style="font-size:1.5em;line-height:1.6;max-width:800px;text-align:center;">
        Now, it’s your turn! After each round, choose whether the music got higher, lower or stayed the same.
      </p>
      <audio id="finalNarration" src="PT_PITCH_FINAL.mp3"></audio>
    </div>
  `);

  const audio = document.getElementById("finalNarration");
  if (audio) {
    audio.play().catch(() => {});
    audio.onended = runPitchPractice;
  } else {
    runPitchPractice();
  }
}
  
function runPitchPractice() {
  const pitchPracticeTrials = [
    { video: "PT_HIGH2.mp4", correct: "high" },
    { video: "PT_LOW2.mp4", correct: "low" },
    { video: "PT_Same.mp4", correct: "same" }
  ];
  
  let i = 0;
  let practiceTrialNum = 1;

  function nextPractice() {
    if (i >= pitchPracticeTrials.length) {
      showPitchInstructions(); // → then instructions page
      return;
    }
    const trial = pitchPracticeTrials[i];
    const proceed = () => {
      i++;
      practiceTrialNum++;
      nextPractice();
    };
    playPitchPracticeVideo(trial.video, trial.correct, proceed, practiceTrialNum);
  }

  nextPractice();
}
function playPitchPracticeVideo(videoFile, correctAnswer, callback, trialNumber) {
  updateScreen(`
    <div style="width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:white;">
      <video id="practiceVideo" playsinline autoplay style="width:100%; height:100%; object-fit:contain; background:white;">
        <source src="${videoFile}" type="video/mp4">
      </video>
    </div>
  `);

  const video = document.getElementById("practiceVideo");
  video.muted = false;
  video.onended = () => {
    showPitchResponseScreen(correctAnswer, callback, videoFile, trialNumber);
  };
  video.play().catch(err => {
    console.warn("Autoplay issue or play failed:", err);
    showPitchResponseScreen(correctAnswer, callback, videoFile, trialNumber);
  });
}

function showPitchResponseScreen(correctAnswer, callback, videoFile, trialNumber) {
  updateScreen(`
    <div class="response-wrapper">
      <div class="response-screen">
        <audio id="pitchPromptAudio" src="pitch_prompt.mp3"></audio>
        <h1>How did the pitch sound?</h1>
        <div class="response-options">
          <button class="tempo-btn" data-choice="high" disabled>
            <img src="high_icon.jpg" alt="High" class="option-icon" />
            <span>High</span>
          </button>
          <button class="tempo-btn" data-choice="low" disabled>
            <img src="low_icon.jpg" alt="Low" class="option-icon" />
            <span>Low</span>
          </button>
          <button class="tempo-btn" data-choice="same" disabled>
            <img src="same_icon.jpg" alt="Same" class="option-icon" />
            <span>Same</span>
          </button>
        </div>
        <audio id="correctSound" src="correct_feedback.mp3"></audio>
        <audio id="wrongSound" src="wrong_feedback.mp3"></audio>
        <div id="feedback" class="response-feedback" role="status" aria-live="polite"></div>
      </div>
    </div>
  `);

 const pitchPromptAudio = document.getElementById("pitchPromptAudio");
  const buttons = document.querySelectorAll('.tempo-btn');

  let buttonsEnabled = false;
  const enableButtons = () => {
    if (buttonsEnabled) return;
    buttonsEnabled = true;
    buttons.forEach(btn => {
      btn.disabled = false;
    });
  };

  // Play the prompt and enable buttons after it ends.
  // If playback fails (missing file, autoplay blocked, etc.) we still
  // enable the buttons so the participant can respond.
  if (pitchPromptAudio) {
    pitchPromptAudio.addEventListener('ended', enableButtons);
    pitchPromptAudio.addEventListener('error', enableButtons);
    const playPromise = pitchPromptAudio.play();
    if (playPromise && typeof playPromise.catch === 'function') {
      playPromise.catch(() => {
        enableButtons();
      });
    }
  } else {
    enableButtons();
  }

  let answered = false;
  const responseStart = performance.now();
  const feedbackEl = document.getElementById("feedback");
  const correctSound = document.getElementById("correctSound");
  const wrongSound = document.getElementById("wrongSound");
  const successColor = "#2e7d32";
  const errorColor = "#c62828";

  buttons.forEach(btn => {
    btn.addEventListener('click', () => {
      if (answered) return;
      answered = true;
      const choice = btn.getAttribute('data-choice');
      buttons.forEach(b => b.disabled = true);

      const reactionTimeSec = parseFloat(((performance.now() - responseStart) / 1000).toFixed(3));
      const entry = {
        participant: participantID,
        session: sessionID,
        block: "pitch_practice",
        trial_num: trialNumber,
        timestamp: new Date().toISOString(),
        choice,
        audio: videoFile,
        correct_answer: correctAnswer,
        reaction_time_sec: reactionTimeSec,
        trial_phase: "practice"
      };

 saveResponse(entry)
.then(() => {
  let feedbackText = "";
  let feedbackAudioSrc = "";
  if (choice === correctAnswer) {
    if (correctAnswer === "same") {
      feedbackText = "Correct! It was the same! That means Melody must have been in a normal elevator this time and not a magical one.";
      feedbackAudioSrc = "feedback_normal.mp3";
    } else {
      feedbackText = "Correct! That means Melody must have been in a magical elevator!";
      feedbackAudioSrc = "feedback_magical.mp3";
    }
    feedbackEl.style.color = successColor;
    feedbackEl.innerText = feedbackText;
    const feedbackAudio = new Audio(feedbackAudioSrc);
    AudioEngine.attach(feedbackAudio);
    feedbackAudio.play().catch(() => {});
    feedbackAudio.onended = () => setTimeout(callback, 1000);
  } else {
    feedbackEl.style.color = errorColor;
    feedbackEl.innerText = "Oops! Let's try that one again.";
    wrongSound.play().catch(() => {});
    wrongSound.onended = () => {
      setTimeout(() => {
        playPitchPracticeVideo(videoFile, correctAnswer, callback, trialNumber);
      }, 500);
    };
  }
})
        .catch(() => {
          feedbackEl.style.color = errorColor;
          feedbackEl.innerText = "We couldn't save your answer. Please try again.";
          answered = false;
          buttons.forEach(b => b.disabled = false);
        });
    });
  });
}
  
function showPitchInstructions() {
  setTimeout(() => {
    updateScreen(`
      <div style="display:flex;justify-content:center;align-items:center;height:100%;background:white;padding:40px;box-sizing:border-box;">
        <p style="font-size:1.5em;line-height:1.8;max-width:800px;text-align:center;">
          I need your help!<br>
          This time, you’ll stay outside while I ride the elevator.<br>
          When the doors close, you won’t hear the music, but it keeps playing for me.<br>
          Keep the song going in your head!<br>
          When the doors open, listen:<br>
          If the music stayed the same, I took the normal elevator.<br>
          If the pitch changed, I took the magical elevator!<br>
          Are you ready? Let’s go!
        </p>
        <audio id="pitchInstructions" src="PITCH_INSTRUCTIONS.mp3"></audio>
      </div>
    `);

    const audio = document.getElementById("pitchInstructions");
    audio.play().then(() => {
      audio.onended = () => setTimeout(() => {
        pitchPracticeCompleted = true;
        currentBlockIndex = 1;
        trialCounter = 1;
        startRealTrials();
      }, 1000);
    }).catch(err => {
      console.warn("Autoplay issue:", err);
      pitchPracticeCompleted = true;
      currentBlockIndex = 1;
      trialCounter = 1;
      startRealTrials();
    });
  }, 1500);
}

/* REAL TRIALS */

function showRealTrialsIntro() {
  updateScreen(`
    <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;
      background: white;
      padding:40px;box-sizing:border-box;">
      <h1 style="color:#4b2e83; font-size:2em; margin-bottom:20px;">Amazing work!</h1>
      <audio id="realInstructionsAudio" src="real_trials_instructions.mp3"></audio>
      <button id="playRealInstructions" class="btn-primary" style="margin-bottom:24px;">Click to Play Instructions</button>
      <p style="max-width:800px; font-size:1.3em; text-align:center; line-height:1.6; margin-bottom:20px;">
        I need your help!<br>
        This time, you’ll stay outside while I ride the elevator.<br>
        When the doors close, you won’t hear the music, but it keeps playing for me.<br>
        Keep the song going in your head!<br>
        When the doors open, listen:<br>
        If the music stayed the same, I took the normal elevator.<br>
        If the speed changed, I took the magical elevator!<br>
        Are you ready? Let’s go!
      </p>
      <button id="startRealTrials" class="btn-primary" style="display:none; margin-top:20px;">Start Real Trials</button>
    </div>
  `);
  
  const playBtn = document.getElementById("playRealInstructions");
  const startBtn = document.getElementById("startRealTrials");
  const audio = document.getElementById("realInstructionsAudio");

  playBtn.addEventListener("click", async () => {
    playBtn.disabled = true;
    try {
      await audio.play();
    } catch (err) {
      console.warn("Autoplay blocked or failed:", err);
    }
    audio.onended = () => {
      startBtn.style.display = "inline-block";
    };
  });

  startBtn.addEventListener("click", startRealTrials);
}

async function startRealTrials() {
  const block = BLOCK_ORDER[currentBlockIndex];

  try {
    if (!blocks[block] || blocks[block].length === 0) {
      updateScreen(`<h2>⚠️ No trials found in ${BLOCK_FILES[block]}. Please check your CSV.</h2>`);
      return;
    }
  } catch (err) {
    updateScreen(`<h2>⚠️ Failed to load block: ${block}<br>${err.message}</h2>`);
    return;
 }

  trialsInCurrentBlock = 0;
  animalsShownInBlock = 0;

  rebuildBaseHTML();
  updatePlayButton();
}

function setupVisualElements() {
  visuals.length=0;
  visuals.push(
    {el:document.getElementById("stillframe1"),start:0,end:0},
    {el:document.getElementById("video1"),start:0,end:0},
    {el:document.getElementById("gapStillframe"),start:0,end:0},
    {el:document.getElementById("gapVideo"),start:0,end:0},
    {el:document.getElementById("video2"),start:0,end:0},
    {el:document.getElementById("stillframe2"),start:0,end:0}
  );
}

function showAutoplayOverlay(audio, callback) {
  const overlay = document.getElementById("overlay");
  overlay.innerHTML =
    '<button id="resumeAudio" class="btn-primary">Start Audio</button>';
  overlay.style.display = "flex";
  document
    .getElementById("resumeAudio")
    .addEventListener(
      "click",
      async () => {
        overlay.style.display = "none";
        try {
          await audio.play();
          callback();
        } catch (err) {
          console.warn("Audio play failed:", err);
        }
      },
      { once: true }
    );
}

function updatePlayButton() {
  const block = BLOCK_ORDER[currentBlockIndex];
  const trialControls = document.getElementById("trialControls");
  const total = trialsFor(block);
  trialControls.innerHTML = `<button id="playButton" class="btn-primary">Start ${block.toUpperCase()} Trial ${trialCounter} of ${total}</button>`;
  document.getElementById("playButton").addEventListener("click", playTrial);
}
function hideAll() {
  visuals.forEach(v => {
    if (!v.el) return;
    v.el.style.display = "none";
    if (v.el.tagName === "VIDEO") {
      try { v.el.pause(); v.el.currentTime = 0; } catch (_) {}
    }
  });
}
  
/**
 * Robust playTrial:
 * - validates trial row shape
 * - parses numeric durations safely
 * - guards against missing video elements/durations
 * - improved filename 'gap' detection using includes('_gap')
 */
// Replace the existing playTrial() in your script with this function.
// It includes robust timeline handling, audio-ended guard, fallback timer,
// defensive CSV/trial checks, and logs useful diagnostics.
async function playTrial() {
  console.log('playTrial called; blockIndex=', currentBlockIndex, 'trialCounter=', trialCounter);

  // Clear UI and stop any leftover media
  document.getElementById("trialControls").innerHTML = "";
  updateScreen("");
  hideAll();

  const block = BLOCK_ORDER[currentBlockIndex];
  const blockArray = blocks[block] || [];
  console.log(`Block "${block}" has ${blockArray.length} rows`);

  const trial = blockArray[trialCounter - 1];
  if (!trial) {
    console.error('No trial data found for', { block, trialCounter, blockLength: blockArray.length, trialRow: trial });
    updateScreen(`<h2>Error: No trial data found for block ${block} trial ${trialCounter}. Please check your CSV and block setup.</h2>`);
    // allow operator to recover
    rebuildBaseHTML();
    updatePlayButton();
    return;
  }

  if (!Array.isArray(trial) || trial.length < 4) {
    console.error('Malformed trial row (expected >=4 columns)', { block, trialCounter, trial });
    updateScreen(`<h2>Error: Malformed trial data for ${block} trial ${trialCounter}. Please check CSV format (comma or tab separated).</h2>`);
    return;
  }

  const [filenameRaw, originalRaw, gapRaw, testRaw] = trial;
  const filename = String(filenameRaw).trim();
  const originalSec = parseFloat(String(originalRaw).trim());
  const gapSec = parseFloat(String(gapRaw).trim());
  const testSec = parseFloat(String(testRaw).trim());

  if (Number.isNaN(originalSec) || Number.isNaN(gapSec) || Number.isNaN(testSec)) {
    console.error('Numeric fields could not be parsed for trial', { filename, originalRaw, gapRaw, testRaw });
    updateScreen(`<h2>Error: Could not parse numeric durations for ${filename}. Check CSV numeric columns.</h2>`);
    return;
  }

  // Prepare audio
  const audio = document.getElementById("myAudio");
  audio.src = filename;
  audio.load();
  currentAudioFile = filename;

  // collect video elements from visuals array (defensive)
  const videoEls = visuals
    .filter(v => v.el && v.el.tagName && v.el.tagName.toUpperCase() === "VIDEO")
    .map(v => v.el);

  if (videoEls.length < 3) {
    console.error('Expected 3 video elements but found', videoEls.length, videoEls);
    updateScreen('<h2>Error: Missing required video elements (video1, gapVideo, video2). Please check your HTML.</h2>');
    return;
  }
  const [v1, vGap, v2] = videoEls;

  // Wait for video metadata (durations)
  try {
    await Promise.all([
      new Promise(res => { if (v1.readyState >= 1) res(); else v1.onloadedmetadata = res; }),
      new Promise(res => { if (vGap.readyState >= 1) res(); else vGap.onloadedmetadata = res; }),
      new Promise(res => { if (v2.readyState >= 1) res(); else v2.onloadedmetadata = res; })
    ]);
  } catch (err) {
    console.warn('Failed waiting for video metadata', err);
  }

  const video1Sec = Number(v1.duration);
  const gapVideoSec = Number(vGap.duration);
  const video2Sec = Number(v2.duration);

  if (isNaN(video1Sec) || isNaN(gapVideoSec) || isNaN(video2Sec)) {
    console.warn('One or more video durations are NaN:', { video1Sec, gapVideoSec, video2Sec });
    updateScreen('<h2>Error: Video files not loaded properly. Please check your video files and try again.</h2>');
    return;
  }

  // Compute timeline pieces
  const preStillSec = Math.max(0, originalSec - video1Sec);
  const gapStillSec = Math.max(0, gapSec - gapVideoSec);
  const postStillSec = Math.max(0, testSec - video2Sec);

  let t = 0;
  visuals[0].start = t; visuals[0].end = t += preStillSec;
  visuals[1].start = t; visuals[1].end = t += video1Sec;
  visuals[2].start = t; visuals[2].end = t += gapStillSec;
  visuals[3].start = t; visuals[3].end = t += gapVideoSec;
  visuals[4].start = t; visuals[4].end = t += video2Sec;
  visuals[5].start = t; visuals[5].end = t += postStillSec;

  console.log('Timeline for trial:', {
    filename,
    originalSec, gapSec, testSec,
    video1Sec, gapVideoSec, video2Sec,
    preStillSec, gapStillSec, postStillSec,
    visualsEnds: visuals.map(v => v.end)
  });

  // Wait for audio ready so waitForAudioReady can catch loading errors
  try {
    await waitForAudioReady(audio);
  } catch (err) {
    console.error("Unable to start trial — audio failed to load.", err);
    updateScreen('<h2>Error: the audio file could not be loaded. Please try again.</h2>');
    updatePlayButton();
    return;
  }

  // Start clock and visuals loop with robust finish conditions
  trialStartTime = performance.now();

  let currentVisual = null;
  let visualsDone = false;
  let fallbackTimer = null;

  function stopAllMedia() {
    // pause audio
    try { audio.pause(); } catch (_) {}
    // pause/rewind videos
    visuals.forEach(v => {
      if (v && v.el && v.el.tagName === "VIDEO") {
        try { v.el.pause(); v.el.currentTime = 0; } catch(_) {}
      }
    });
  }

  function finishVisuals() {
    if (visualsDone) return;
    visualsDone = true;
    try { clearTimeout(fallbackTimer); } catch(_) {}
    try { stopAllMedia(); } catch(_) {}
    try { hideAll(); } catch(_) {}
    // Ensure showResponseOptions errors are caught
    try {
      showResponseOptions();
    } catch (e) {
      console.error("showResponseOptions failed", e);
    }
  }

  function updateVisuals() {
    // If audio ended, finish immediately
    if (audio.ended) {
      finishVisuals();
      return;
    }

    // master clock: audio.currentTime if available, otherwise wall-clock elapsed
    const time = (typeof audio.currentTime === "number" && !Number.isNaN(audio.currentTime))
      ? audio.currentTime
      : ((performance.now() - trialStartTime) / 1000);

    // Update which visual should be visible
    for (const v of visuals) {
      if (time >= v.start && time < v.end) {
        if (currentVisual !== v.el) {
          // show this visual
          hideAll();
          if (v.el) {
            v.el.style.display = "block";
            if (v.el.tagName === "VIDEO") {
              try { v.el.currentTime = 0; v.el.play().catch(()=>{}); } catch(_) {}
            }
          }
          currentVisual = v.el;
        }
        break;
      }
    }

    const lastEnd = visuals[visuals.length - 1]?.end ?? 0;
    if (audio.ended || time >= lastEnd) {
      finishVisuals();
    } else {
      requestAnimationFrame(updateVisuals);
    }
  }

  // Ensure visuals finish when audio ends
  const onAudioEnded = () => finishVisuals();
  audio.addEventListener('ended', onAudioEnded, { once: true });

  // Safety fallback: lastEnd + margin or at least 30s
  const lastEndSec = visuals[visuals.length - 1]?.end || 30;
  const fallbackMs = Math.max(30000, (lastEndSec + 3) * 1000);
  fallbackTimer = setTimeout(() => {
    console.warn("Fallback timer firing to finish visuals");
    finishVisuals();
  }, fallbackMs);

  // Try to play audio; start visuals loop regardless (visuals uses wall-time fallback)
  try {
    const playPromise = audio.play();
    if (playPromise && typeof playPromise.then === 'function') {
      playPromise
        .then(() => {
          // started successfully; visuals will follow audio.currentTime
          requestAnimationFrame(updateVisuals);
        })
        .catch(err => {
          // playback blocked — still start visuals using wall-clock elapsed
          console.warn("audio.play() rejected:", err);
          requestAnimationFrame(updateVisuals);
        });
    } else {
      // older browsers: start visuals loop
      requestAnimationFrame(updateVisuals);
    }
  } catch (err) {
    console.warn("audio.play() threw:", err);
    requestAnimationFrame(updateVisuals);
  }
}
  
function showResponseOptions() {
  updateScreen(`
    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 20px; background: white;">
      <audio id="elevatorQuestionAudio" src="elevator_question.mp3"></audio>
      <h1 style="color: #4b2e83;">Which elevator did Melody ride?</h1>
      <p style="max-width:600px;font-size:1.1em;margin-bottom:30px;">
        Now that the music is over, think back to how it sounded before and after the pause.<br><br>
        If the music stayed the same, choose the <strong>normal</strong> elevator.<br>
        If the music changed after the pause, choose the <strong>magical</strong> elevator.
      </p>
      <div style="display:flex;justify-content:center;gap:80px;">
        <div style="text-align:center;">
          <img src="normal.jpg" class="elevator-option" id="normalElevator" alt="Normal Elevator" style="width:300px;">
          <div style="margin-top:px;font-weight:bold;">Normal Elevator</div>
        </div>
        <div style="text-align:center;">
          <img src="magical.png" class="elevator-option" id="magicalElevator" alt="Magical Elevator" style="width:300px;">
          <div style="margin-top:px;font-weight:bold;">Magical Elevator</div>
        </div>
      </div>
    </div>`);

  // Play the narration automatically
  const narration = document.getElementById("elevatorQuestionAudio");
  if (narration) {
    narration.play().catch(() => {});
  }
  
  document.getElementById("normalElevator").addEventListener("click", () => handleResponse("normal"), { once: true });
  document.getElementById("magicalElevator").addEventListener("click", () => handleResponse("magical"), { once: true });
}

function handleResponse(choice) {
  if (responseSubmitted) return;
  responseSubmitted = true;

  const imgs = document.querySelectorAll('.elevator-option');
  imgs.forEach(img => img.style.pointerEvents = 'none');

  const reactionTimeSec = (performance.now() - trialStartTime) / 1000;
  // Robust gap detection: if filename includes '_gap' treat as normal
  const isNormal = typeof currentAudioFile === 'string' && currentAudioFile.includes('_gap');
  const correctAnswer = isNormal ? "normal" : "magical";

  const entry = {
    participant: participantID,
    session: sessionID,
    block: BLOCK_ORDER[currentBlockIndex],
    trial_num: trialCounter,
    timestamp: new Date().toISOString(),
    choice,
    audio: currentAudioFile,
    correct_answer: correctAnswer,
    reaction_time_sec: parseFloat(reactionTimeSec.toFixed(3)),
    trial_phase: "real"
  };

  const advanceToNextTrial = () => {
    trialsInCurrentBlock++;
    trialCounter++;

    const currentBlockName = BLOCK_ORDER[currentBlockIndex];
    const currentBlockTotal = trialsFor(currentBlockName);

    if (trialCounter > currentBlockTotal) {
      trialCounter = 1;
      currentBlockIndex++;
    }

    completedTrials++;
    updateProgress();

      const scheduledAnimalTrials = REAL_BLOCK_ANIMAL_TRIALS[currentBlockName];
    let showAnimal = false;

    if (Array.isArray(scheduledAnimalTrials) && scheduledAnimalTrials.length) {
      showAnimal = scheduledAnimalTrials.includes(trialsInCurrentBlock)
        && animalsShownInBlock < scheduledAnimalTrials.length;
    } else {
      const animalInterval = animalIntervalFor(currentBlockName);
      showAnimal = (animalInterval > 0)
        && (trialsInCurrentBlock % animalInterval === 0)
        && (animalsShownInBlock < ANIMALS_PER_BLOCK);
    }

    const proceed = () => {
      if (currentBlockIndex >= BLOCK_ORDER.length) {
        showParty();
      } else if (BLOCK_ORDER[currentBlockIndex] === "pitch" && !pitchPracticeCompleted) {
        runPitchDemo();
      } else {
        rebuildBaseHTML();
        updatePlayButton();
      }
    };

    if (showAnimal) {
      animalsShownInBlock++;
      showAnimalScreen(proceed);
    } else {
      proceed();
    }
  };

  saveResponse(entry)
    .then(() => {
      advanceToNextTrial();
    })
    .catch((err) => {
      console.error("Failed to record response", err);
      if (queueOfflineResponse(entry, err)) {
        alert("We couldn't reach the server, but your answer was saved locally. You can keep going!");
        advanceToNextTrial();
        flushOfflineQueue().catch(e => console.warn("Failed to flush offline queue after queuing response", e));
        return;
      }
      alert("Failed to record response. Please try again.");
      responseSubmitted = false;
      imgs.forEach(img => img.style.pointerEvents = 'auto');
      const normal = document.getElementById("normalElevator");
      const magical = document.getElementById("magicalElevator");
      if (normal && magical) {
        normal.addEventListener("click", () => handleResponse("normal"), { once: true });
        magical.addEventListener("click", () => handleResponse("magical"), { once: true });
      }
    });
}

function updateProgress() {
  const total = totalTrialsCount();
  if (total <= 0) return;
  const percent = (completedTrials / total) * 100;
  document.getElementById("progressBar").style.width = percent + "%";
}

function showAnimalScreen(callback) {
  const animal = ANIMALS[animalIndex % ANIMALS.length];
  animalIndex++;

  updateScreen(`
    <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;background:white;padding:20px;">
      <img src="${animal.image}" alt="${animal.name}" style="max-width:40%;height:auto;margin-bottom:20px;"/>
      <h2>Ding! We stopped at the ${animal.name}'s floor!</h2>
      <p style="margin-top:10px;font-size:1.2em;">${animal.action} Then click Continue to ride again.</p>
      <button id="continueAnimal" class="btn-primary" style="margin-top:20px;" type="button" disabled>Continue (<span id="animalCountdown">45</span>s)</button>
    </div>
  `);

  // Play the animal sound (don’t await)
  currentAnimalAudio = animal.audio ?? null;
  if (currentAnimalAudio) {
    try {
      currentAnimalAudio.currentTime = 0;
      currentAnimalAudio.play().catch(() => {});
    } catch (_) {}
  }

  const btn = document.getElementById("continueAnimal");
  const countdownEl = document.getElementById("animalCountdown");
  let secondsLeft = 20;
  btn.disabled = true;

  // Countdown timer
  const timer = setInterval(() => {
    secondsLeft--;
    countdownEl.textContent = secondsLeft;
    if (secondsLeft <= 0) {
      clearInterval(timer);
      btn.disabled = false;
      btn.textContent = "Continue";
    }
  }, 1000);

  btn.addEventListener("click", () => {
    // Stop any ongoing animal audio immediately
    if (currentAnimalAudio) {
      try {
        currentAnimalAudio.pause();
        currentAnimalAudio.currentTime = 0;
      } catch (_) {}
      currentAnimalAudio = null;
    }
    // Debounce extra taps and proceed right away
    btn.disabled = true;
    callback();
  }, { once: true });
}
  
function showParty({ onDone, autoStart = false } = {}) {
  // ---- quick CSS (animations + grid) ----
  const css = `
  #party-wrap {height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;background:#fff;gap:18px;padding:20px; position:relative; overflow:hidden;}
  #animal-grid {display:grid;grid-template-columns:repeat(auto-fit,minmax(110px,1fr));gap:16px;max-width:900px;width:100%;}
  .animal {display:flex;flex-direction:column;align-items:center;gap:6px}
  .animal img {width:110px;height:auto;filter: drop-shadow(0 2px 6px rgba(0,0,0,.15));}
  .label {font-size:14px;color:#333}
  .dance1 {animation: bob 1.8s ease-in-out infinite;}
  .dance2 {animation: wobble 1.6s ease-in-out infinite;}
  .dance3 {animation: hop 1.2s ease-in-out infinite;}
  @keyframes bob {0%,100%{transform:translateY(0)}50%{transform:translateY(-8px)}}
  @keyframes wobble {0%,100%{transform:rotate(0)}50%{transform:rotate(-6deg)}}
  @keyframes hop {0%,100%{transform:translateY(0)}35%{transform:translateY(-10px)}}
  #party-cta {display:flex; gap:10px; flex-wrap:wrap; justify-content:center}
  .btn {padding:10px 14px;border:none;border-radius:999px;background:#4b2e83;color:#fff;font-weight:600;cursor:pointer;box-shadow:0 2px 8px rgba(0,0,0,.12);}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  #confetti {position:absolute; inset:0; pointer-events:none}
  `;
  injectStyleOnce("party-css", css);

  // ---- screen ----
  updateScreen(`
    <div id="party-wrap">
      <canvas id="confetti"></canvas>
      <h1 style="color:#4b2e83;margin:0;">Great job! It’s party time! 🎉</h1>
      <div id="animal-grid">
        ${ANIMALS.map((a,i)=>`
          <div class="animal ${['dance1','dance2','dance3'][i%3]}">
            <img src="${a.image}" alt="${a.name}">
            <div class="label">${a.name}</div>
          </div>
        `).join('')}
      </div>
      <div id="party-cta">
        <button id="startParty" class="btn">Start the party 🎈</button>
        ${onDone ? `<button id="continueBtn" class="btn">Continue ▶</button>` : ``}
      </div>
    </div>
  `);

  // ---- audio (gated by a click) ----
  const musicGain = (window.groups?.music ?? 1.0);
  const sfxGain   = (window.groups?.sfx   ?? 1.0);
  const narrationGain = (window.groups?.narration ?? 1.0);

  const bgm = new Audio('party_music_loop.mp3'); // short, upbeat loop (8–15s)
  bgm.loop = true; bgm.volume = 0.6 * musicGain;

  const cheer = new Audio('kids_cheer.mp3');
  cheer.volume = 0.9 * sfxGain;

  const outro = new Audio('PARTY_OUTRO.mp3'); // “You did it! Thanks for playing…”
  outro.volume = 0.95 * narrationGain;

  const startBtn = document.getElementById('startParty');
  const contBtn = document.getElementById('continueBtn');

  const canvas = document.getElementById('confetti');
  const ctx = canvas?.getContext('2d');
  const sprites = [];
  const transientSprites = [];

  async function runPartySequence() {
    if (!startBtn || startBtn.disabled) return;

    startBtn.disabled = true;

    burstConfetti(600);

    try {
      cheer.currentTime = 0;
      await cheer.play();
    } catch (err) {
      // Browser blocked autoplay (likely no user gesture). Allow manual retry.
      startBtn.disabled = false;
      throw err;
    }

    setTimeout(() => {
      try { bgm.currentTime = 0; bgm.play(); } catch {}
      try { outro.currentTime = 0; outro.play(); } catch {}
    }, 200);
  }

  startBtn?.addEventListener('click', () => {
    runPartySequence().catch(() => {});
  });

  if (autoStart) {
    runPartySequence().catch(() => {});
  }

  contBtn?.addEventListener('click', () => {
    try { bgm.pause(); } catch {}
    onDone?.();
  });

  // pause music if user leaves this screen
  addScreenCleanup(() => { try { bgm.pause(); } catch {} });

  if (canvas && ctx) {
    startConfettiLoop();
  }

  function injectStyleOnce(id, cssText){
    if (!document.getElementById(id)) {
      const s = document.createElement('style'); s.id=id; s.textContent=cssText; document.head.appendChild(s);
    }
  }

  function burstConfetti(durationMs=800){
    if (!canvas || !ctx) return;

    const bursts = [];
    for (let i=0;i<40;i++){
      bursts.push({
        x: Math.random(), y: -0.1, vy: 0.004 + Math.random()*0.006,
        vx: (Math.random()-.5)*0.003, rot: Math.random()*Math.PI*2, vr: (Math.random()-.5)*0.2,
        txt: ["🎉","✨","🎈","💫","⭐","🎊"][Math.floor(Math.random()*6)], life: durationMs
      });
    }
    transientSprites.push(...bursts);
    setTimeout(()=>{
      transientSprites.splice(0, bursts.length);
    }, durationMs);
  }

  function startConfettiLoop(){
    const resize = () => {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
    };
    resize();
    new ResizeObserver(resize).observe(canvas);

    for (let i=0;i<50;i++){
      sprites.push({
        x: Math.random(), y: Math.random(), vy: 0.001 + Math.random()*0.002,
        vx: (Math.random()-.5)*0.0015, rot: Math.random()*Math.PI*2, vr: (Math.random()-.5)*0.05,
        txt: ["🎉","✨","🎈","💫","⭐","🎊"][Math.floor(Math.random()*6)]
      });
    }

    function tick(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const all = sprites.concat(transientSprites);
      for (const p of all){
        p.x += p.vx; p.y += p.vy; p.rot += p.vr;
        if (p.y > 1.1) { p.y = -0.1; p.x = Math.random(); }
        const px = p.x * canvas.width, py = p.y * canvas.height;
        ctx.save(); ctx.translate(px, py); ctx.rotate(p.rot);
        ctx.font = `${Math.max(14, canvas.width*0.02)}px system-ui, emoji`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(p.txt, 0, 0);
        ctx.restore();
      }
      requestAnimationFrame(tick);
    }
    tick();
  }
}
  
function rebuildBaseHTML() {
  updateScreen("");
  document.getElementById("trialControls").innerHTML="";
  responseSubmitted=false;
  setupVisualElements();
}
setupVisualElements();

/* Utility to allow party audio cleanup hook (keeps parity with earlier code which referenced it) */
const _screenCleanupFns = [];
function addScreenCleanup(fn) {
  if (typeof fn === 'function') _screenCleanupFns.push(fn);
}
function runScreenCleanup() {
  while (_screenCleanupFns.length) {
    const fn = _screenCleanupFns.shift();
    try { fn(); } catch (_) {}
  }
}

/* End of script */
</script>
</body>
</html>

































